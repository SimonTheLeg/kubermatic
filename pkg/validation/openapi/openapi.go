package openapi

import (
	"embed"
	"errors"
	"fmt"
	"io"
	"strings"

	"io/fs"

	"github.com/gobuffalo/flect"
	ext "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions"
	extv1 "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
	"k8s.io/apiextensions-apiserver/pkg/apiserver/validation"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/util/yaml"
	"k8s.io/kube-openapi/pkg/validation/validate"
)

// ValidatorFromCRD creates a new validator based on the supplied crd.
// The CRD must be in yaml or json representation.
// As a CRD can contain multiple versions, a desired one needs to be specified
func ValidatorFromCRD(crd io.Reader, desVer string) (*validate.SchemaValidator, error) {
	crdv1 := &extv1.CustomResourceDefinition{}

	dec := yaml.NewYAMLOrJSONDecoder(crd, 1024)
	err := dec.Decode(crdv1)
	if err != nil {
		return nil, err
	}

	// Currently there is an issue in the k8s yaml package when working with documents that start with a blank line and the yaml document separator
	// (https://github.com/kubernetes/apimachinery/issues/133). So for now we work around the empty buffer by re-reading from it
	// Note: alternative yaml packages (e.g. gopkg.in/yaml) cannot be used, as they do not handle kubernetes-specifc struct tags
	if crdv1.TypeMeta.APIVersion == "" {
		err := dec.Decode(crdv1)
		if err != nil {
			return nil, err
		}
	}

	crdr := &ext.CustomResourceDefinition{}
	if err := extv1.Convert_v1_CustomResourceDefinition_To_apiextensions_CustomResourceDefinition(crdv1, crdr, nil); err != nil {
		return nil, err
	}

	var sv *validate.SchemaValidator
	for _, ver := range crdr.Spec.Versions {
		if ver.Name == desVer {

			// if per-version validation is enabled, use it; otherwise use global validation
			if ver.Schema != nil {
				sv, _, err = validation.NewSchemaValidator(ver.Schema)
			} else {
				sv, _, err = validation.NewSchemaValidator(crdr.Spec.Validation)
			}
			if err != nil {
				return nil, err
			}
			return sv, nil
		}
	}

	if sv == nil {
		return nil, fmt.Errorf("could not find SchemaValidator for desired version %q", desVer)
	}

	return sv, nil
}

//go:embed crd/k8c.io
var efs embed.FS

// ValidatorForType returns a suitable validator from its catalogue based on the supplied TypeMeta
func ValidatorForType(tm *metav1.TypeMeta) (*validate.SchemaValidator, error) {

	// as filenames are being generated by controller-gen, use the same pluralization mechanism
	// https://github.com/kubernetes-sigs/controller-tools/blob/8cb5ce83c3cca425a4de0af3d2578e31a3cd6a48/pkg/crd/spec.go#L58
	kindPlural := strings.ToLower(flect.Pluralize(tm.GroupVersionKind().Kind))
	crdfpath := "crd/k8c.io/" + tm.GroupVersionKind().Group + "_" + kindPlural + ".yaml"

	f, err := efs.Open(crdfpath)
	if err != nil {
		if errors.Is(err, fs.ErrNotExist) {
			return nil, fmt.Errorf("could not find validator for type \"%s_%s\"", tm.GroupVersionKind().Group, kindPlural)
		}
		return nil, err
	}

	v, err := ValidatorFromCRD(f, tm.GroupVersionKind().Version)
	if err != nil {
		return nil, err
	}

	return v, nil
}
